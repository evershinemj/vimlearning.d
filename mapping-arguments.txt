1.2 SPECIAL ARGUMENTS					*:map-arguments*

"<buffer>", "<nowait>", "<silent>", "<special>", "<script>", "<expr>" and
"<unique>" can be used in any order.  They must appear right after the
command, before any other arguments.

				*:map-local* *:map-<buffer>* *E224* *E225*
If the first argument to one of these commands is "<buffer>" the mapping will
be effective in the current buffer only.  Example: >
	:map <buffer>  ,w  /[.,;]<CR>
Then you can map ",w" to something else in another buffer: >
	:map <buffer>  ,w  /[#&!]<CR>
The local buffer mappings are used before the global ones.  See <nowait> below
to make a short local mapping not taking effect when a longer global one
exists.
The "<buffer>" argument can also be used to clear mappings: >
	:unmap <buffer> ,w
	:mapclear <buffer>
Local mappings are also cleared when a buffer is deleted, but not when it is
unloaded.  Just like local option values.
Also see |map-precedence|.

						*:map-<nowait>* *:map-nowait*
When defining a buffer-local mapping for "," there may be a global mapping
that starts with ",".  Then you need to type another character for Vim to know
whether to use the "," mapping or the longer one.  To avoid this add the
<nowait> argument.  Then the mapping will be used when it matches, Vim does
not wait for more characters to be typed.  However, if the characters were
already typed they are used.

						*:map-<silent>* *:map-silent*
To define a mapping which will not be echoed on the command line, add
"<silent>" as the first argument.  Example: >
	:map <silent> ,h /Header<CR>
The search string will not be echoed when using this mapping.  Messages from
the executed command are still given though.  To shut them up too, add a
":silent" in the executed command: >
	:map <silent> ,h :exe ":silent normal /Header\r"<CR>
Prompts will still be given, e.g., for inputdialog().
Using "<silent>" for an abbreviation is possible, but will cause redrawing of
the command line to fail.

						*:map-<special>* *:map-special*
Define a mapping with <> notation for special keys, even though the "<" flag
may appear in 'cpoptions'.  This is useful if the side effect of setting
'cpoptions' is not desired.  Example: >
	:map <special> <F12> /Header<CR>
<
						*:map-<script>* *:map-script*
If the first argument to one of these commands is "<script>" and it is used to
define a new mapping or abbreviation, the mapping will only remap characters
in the {rhs} using mappings that were defined local to a script, starting with
"<SID>".  This can be used to avoid that mappings from outside a script
interfere (e.g., when CTRL-V is remapped in mswin.vim), but do use other
mappings defined in the script.
Note: ":map <script>" and ":noremap <script>" do the same thing.  The
"<script>" overrules the command name.  Using ":noremap <script>" is
preferred, because it's clearer that remapping is (mostly) disabled.

						*:map-<unique>* *E226* *E227*
If the first argument to one of these commands is "<unique>" and it is used to
define a new mapping or abbreviation, the command will fail if the mapping or
abbreviation already exists.  Example: >
	:map <unique> ,w  /[#&!]<CR>
When defining a local mapping, there will also be a check if a global map
already exists which is equal.
Example of what will fail: >
	:map ,w  /[#&!]<CR>
	:map <buffer> <unique> ,w  /[.,;]<CR>
If you want to map a key and then have it do what it was originally mapped to,
have a look at |maparg()|.

						*:map-<expr>* *:map-expression*
If the first argument to one of these commands is "<expr>" and it is used to
define a new mapping or abbreviation, the argument is an expression.  The
expression is evaluated to obtain the {rhs} that is used.  Example: >
	:inoremap <expr> . InsertDot()
The result of the InsertDot() function will be inserted.  It could check the
text before the cursor and start omni completion when some condition is met.

For abbreviations |v:char| is set to the character that was typed to trigger
the abbreviation.  You can use this to decide how to expand the {lhs}.  You
should not either insert or change the v:char.

Be very careful about side effects!  The expression is evaluated while
obtaining characters, you may very well make the command dysfunctional.
For this reason the following is blocked:
- Changing the buffer text |textlock|.
- Editing another buffer.
- The |:normal| command.
- Moving the cursor is allowed, but it is restored afterwards.
If you want the mapping to do any of these let the returned characters do
that.

You can use getchar(), it consumes typeahead if there is any. E.g., if you
have these mappings: >
  inoremap <expr> <C-L> nr2char(getchar())
  inoremap <expr> <C-L>x "foo"
If you now type CTRL-L nothing happens yet, Vim needs the next character to
decide what mapping to use.  If you type 'x' the second mapping is used and
"foo" is inserted.  If you type any other key the first mapping is used,
getchar() gets the typed key and returns it.

Here is an example that inserts a list number that increases: >
	let counter = 0
	inoremap <expr> <C-L> ListItem()
	inoremap <expr> <C-R> ListReset()

	func ListItem()
	  let g:counter += 1
	  return g:counter . '. '
	endfunc

	func ListReset()
	  let g:counter = 0
	  return ''
	endfunc

CTRL-L inserts the next number, CTRL-R resets the count.  CTRL-R returns an
empty string, so that nothing is inserted.

Note that there are some tricks to make special keys work and escape CSI bytes
in the text.  The |:map| command also does this, thus you must avoid that it
is done twice.  This does not work: >
	:imap <expr> <F3> "<Char-0x611B>"
Because the <Char- sequence is escaped for being a |:imap| argument and then
again for using <expr>.  This does work: >
	:imap <expr> <F3> "\u611B"
Using 0x80 as a single byte before other text does not work, it will be seen
as a special key.
